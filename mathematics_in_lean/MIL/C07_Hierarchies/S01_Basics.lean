import MIL.Common
import Mathlib.Algebra.BigOperators.Ring
import Mathlib.Data.Real.Basic

set_option autoImplicit true

-- ‰Ωï„ÇíË®Ä„Å£„Å¶„ÅÑ„Çã„ÅÆ„Åã
example (a : ‚Ñï) : ‚Ñï := by exact a

class One‚ÇÅ (Œ± : Type) where
  /-- The element one -/
  one : Œ±


#check One‚ÇÅ.one -- One‚ÇÅ.one {Œ± : Type} [self : One‚ÇÅ Œ±] : Œ±

@[class] structure One‚ÇÇ (Œ± : Type) where
  /-- The element one -/
  one : Œ±

#check One‚ÇÇ.one


example (Œ± : Type) [One‚ÇÅ Œ±] : Œ± := One‚ÇÅ.one

example (Œ± : Type) [One‚ÇÅ Œ±] := (One‚ÇÅ.one : Œ±)

@[inherit_doc]
notation "ùüô" => One‚ÇÅ.one

example {Œ± : Type} [One‚ÇÅ Œ±] : Œ± := ùüô

example {Œ± : Type} [One‚ÇÅ Œ±] : (ùüô : Œ±) = ùüô := rfl


class Dia‚ÇÅ (Œ± : Type) where
  dia : Œ± ‚Üí Œ± ‚Üí Œ±

infixl:70 " ‚ãÑ "   => Dia‚ÇÅ.dia


class Semigroup‚ÇÅ (Œ± : Type) where
  toDia‚ÇÅ : Dia‚ÇÅ Œ±
  /-- Diamond is associative -/
  dia_assoc : ‚àÄ a b c : Œ±, a ‚ãÑ b ‚ãÑ c = a ‚ãÑ (b ‚ãÑ c)


attribute [instance] Semigroup‚ÇÅ.toDia‚ÇÅ

example {Œ± : Type} [Semigroup‚ÇÅ Œ±] (a b : Œ±) : Œ± := a ‚ãÑ b
example {Œ± : Type} [Semigroup‚ÇÅ Œ±] (a _b : Œ±) : Œ± := by exact a

class Semigroup‚ÇÇ (Œ± : Type) extends Dia‚ÇÅ Œ± where
  /-- Diamond is associative -/
  dia_assoc : ‚àÄ a b c : Œ±, a ‚ãÑ b ‚ãÑ c = a ‚ãÑ (b ‚ãÑ c)

example {Œ± : Type} [Semigroup‚ÇÇ Œ±] (a b : Œ±) : Œ± := a ‚ãÑ b

class DiaOneClass‚ÇÅ (Œ± : Type) extends One‚ÇÅ Œ±, Dia‚ÇÅ Œ± where
  /-- One is a left neutral element for diamond. -/
  one_dia : ‚àÄ a : Œ±, ùüô ‚ãÑ a = a
  /-- One is a right neutral element for diamond -/
  dia_one : ‚àÄ a : Œ±, a ‚ãÑ ùüô = a



set_option trace.Meta.synthInstance true in
example {Œ± : Type} [DiaOneClass‚ÇÅ Œ±] (a b : Œ±) : Prop := a ‚ãÑ b = ùüô


class Monoid‚ÇÅ (Œ± : Type) extends Semigroup‚ÇÅ Œ±, DiaOneClass‚ÇÅ Œ±


class Monoid‚ÇÇ (Œ± : Type) where
  toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±
  toDiaOneClass‚ÇÅ : DiaOneClass‚ÇÅ Œ±


example {Œ± : Type} [Monoid‚ÇÅ Œ±] :
  (Monoid‚ÇÅ.toSemigroup‚ÇÅ.toDia‚ÇÅ.dia : Œ± ‚Üí Œ± ‚Üí Œ±) = Monoid‚ÇÅ.toDiaOneClass‚ÇÅ.toDia‚ÇÅ.dia := rfl


/- Monoid‚ÇÇ.mk {Œ± : Type} (toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±) (toDiaOneClass‚ÇÅ : DiaOneClass‚ÇÅ Œ±) : Monoid‚ÇÇ Œ± -/
#check Monoid‚ÇÇ.mk

/- Monoid‚ÇÅ.mk {Œ± : Type} [toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±] [toOne‚ÇÅ : One‚ÇÅ Œ±] (one_dia : ‚àÄ (a : Œ±), ùüô ‚ãÑ a = a) (dia_one : ‚àÄ (a : Œ±), a ‚ãÑ ùüô = a) : Monoid‚ÇÅ Œ± -/
#check Monoid‚ÇÅ.mk


#check Monoid‚ÇÅ.toSemigroup‚ÇÅ
#check Monoid‚ÇÅ.toDiaOneClass‚ÇÅ


class Inv‚ÇÅ (Œ± : Type) where
  /-- The inversion function -/
  inv : Œ± ‚Üí Œ±

@[inherit_doc]
postfix:max "‚Åª¬π" => Inv‚ÇÅ.inv

class Group‚ÇÅ (G : Type) extends Monoid‚ÇÅ G, Inv‚ÇÅ G where
  inv_dia : ‚àÄ a : G, a‚Åª¬π ‚ãÑ a = ùüô


lemma left_inv_eq_right_inv‚ÇÅ {M : Type} [Monoid‚ÇÅ M] {a b c : M} (hba : b ‚ãÑ a = ùüô) (hac : a ‚ãÑ c = ùüô) : b = c := by
  rw [‚Üê DiaOneClass‚ÇÅ.one_dia c, ‚Üê hba, Semigroup‚ÇÅ.dia_assoc, hac, DiaOneClass‚ÇÅ.dia_one b]


export DiaOneClass‚ÇÅ (one_dia dia_one)
export Semigroup‚ÇÅ (dia_assoc)
export Group‚ÇÅ (inv_dia)


example {M : Type} [Monoid‚ÇÅ M] {a b c : M} (hba : b ‚ãÑ a = ùüô) (hac : a ‚ãÑ c = ùüô) : b = c := by
  rw [‚Üê one_dia c, ‚Üê hba, dia_assoc, hac, dia_one b]


lemma inv_eq_of_dia [Group‚ÇÅ G] {a b : G} (h : a ‚ãÑ b = ùüô) : a‚Åª¬π = b := by
  symm
  calc
    b = ùüô ‚ãÑ b := by exact symm (one_dia b)
    _ = (a‚Åª¬π ‚ãÑ a) ‚ãÑ b := by rw [inv_dia]
    _ = a‚Åª¬π ‚ãÑ (a ‚ãÑ b) := by rw [dia_assoc]
    _ = a‚Åª¬π ‚ãÑ ùüô := by rw [h]
    _ = a‚Åª¬π := by rw [dia_one]

lemma dia_inv [Group‚ÇÅ G] (a : G) : a ‚ãÑ a‚Åª¬π = ùüô := by
  have dbl : a‚Åª¬π‚Åª¬π = a := by refine inv_eq_of_dia (inv_dia a)
  have inv : a‚Åª¬π‚Åª¬π ‚ãÑ a‚Åª¬π = ùüô := by exact inv_dia a‚Åª¬π
  rw [dbl] at inv
  exact inv

class AddSemigroup‚ÇÉ (Œ± : Type) extends Add Œ± where
/-- Addition is associative -/
  add_assoc‚ÇÉ : ‚àÄ a b c : Œ±, a + b + c = a + (b + c)

@[to_additive AddSemigroup‚ÇÉ]
class Semigroup‚ÇÉ (Œ± : Type) extends Mul Œ± where
/-- Multiplication is associative -/
  mul_assoc‚ÇÉ : ‚àÄ a b c : Œ±, a * b * c = a * (b * c)

class AddMonoid‚ÇÉ (Œ± : Type) extends AddSemigroup‚ÇÉ Œ±, AddZeroClass Œ±

@[to_additive AddMonoid‚ÇÉ]
class Monoid‚ÇÉ (Œ± : Type) extends Semigroup‚ÇÉ Œ±, MulOneClass Œ±

attribute [to_additive existing] Monoid‚ÇÉ.toMulOneClass

export Semigroup‚ÇÉ (mul_assoc‚ÇÉ)
export AddSemigroup‚ÇÉ (add_assoc‚ÇÉ)

whatsnew in
@[to_additive]
lemma left_inv_eq_right_inv' {M : Type} [Monoid‚ÇÉ M] {a b c : M} (hba : b * a = 1) (hac : a * c = 1) : b = c := by
  rw [‚Üê one_mul c, ‚Üê hba, mul_assoc‚ÇÉ, hac, mul_one b]

#check left_neg_eq_right_neg'

class AddCommSemigroup‚ÇÉ (Œ± : Type) extends AddSemigroup‚ÇÉ Œ± where
  add_comm : ‚àÄ a b : Œ±, a + b = b + a

@[to_additive AddCommSemigroup‚ÇÉ]
class CommSemigroup‚ÇÉ (Œ± : Type) extends Semigroup‚ÇÉ Œ± where
  mul_comm : ‚àÄ a b : Œ±, a * b = b * a

class AddCommMonoid‚ÇÉ (Œ± : Type) extends AddMonoid‚ÇÉ Œ±, AddCommSemigroup‚ÇÉ Œ±

@[to_additive AddCommMonoid‚ÇÉ]
class CommMonoid‚ÇÉ (Œ± : Type) extends Monoid‚ÇÉ Œ±, CommSemigroup‚ÇÉ Œ±

class AddGroup‚ÇÉ (G : Type) extends AddMonoid‚ÇÉ G, Neg G where
  neg_add : ‚àÄ a : G, -a + a = 0

@[to_additive AddGroup‚ÇÉ]
class Group‚ÇÉ (G : Type) extends Monoid‚ÇÉ G, Inv G where
  inv_mul : ‚àÄ a : G, a‚Åª¬π * a = 1


attribute [simp] Group‚ÇÉ.inv_mul AddGroup‚ÇÉ.neg_add



@[to_additive]
lemma inv_eq_of_mul [Group‚ÇÉ G] {a b : G} (h : a * b = 1) : a‚Åª¬π = b := by
  have one : a‚Åª¬π * a = 1 := by exact Group‚ÇÉ.inv_mul a
  exact left_inv_eq_right_inv' one h

@[to_additive (attr := simp)]
lemma Group‚ÇÉ.mul_inv {G : Type} [Group‚ÇÉ G] {a : G} : a * a‚Åª¬π = 1 := by
  have dbl : a‚Åª¬π‚Åª¬π = a := by refine inv_eq_of_mul (inv_mul a)
  symm
  calc
    1 = a‚Åª¬π‚Åª¬π * a‚Åª¬π := by rw [‚Üêinv_mul]
    _ = a * a‚Åª¬π := by rw [dbl]

@[to_additive]
lemma mul_left_cancel‚ÇÉ {G : Type} [Group‚ÇÉ G] {a b c : G} (h : a * b = a * c) : b = c := by
  rw [‚Üêone_mul b, ‚Üêone_mul c]
  rw [‚ÜêGroup‚ÇÉ.inv_mul a, mul_assoc‚ÇÉ, mul_assoc‚ÇÉ, h]

@[to_additive]
lemma mul_right_cancel‚ÇÉ {G : Type} [Group‚ÇÉ G] {a b c : G} (h : b * a = c * a) : b = c := by
  rw [‚Üêmul_one b, ‚Üêmul_one c]
  rw [‚Üê@Group‚ÇÉ.mul_inv _ _ a, ‚Üêmul_assoc‚ÇÉ, ‚Üêmul_assoc‚ÇÉ, h]

class AddCommGroup‚ÇÉ (G : Type) extends AddGroup‚ÇÉ G, AddCommMonoid‚ÇÉ G

@[to_additive AddCommGroup‚ÇÉ]
class CommGroup‚ÇÉ (G : Type) extends Group‚ÇÉ G, CommMonoid‚ÇÉ G



class Ring‚ÇÉ (R : Type) extends AddGroup‚ÇÉ R, Monoid‚ÇÉ R, MulZeroClass R where
  /-- Multiplication is left distributive over addition -/
  left_distrib : ‚àÄ a b c : R, a * (b + c) = a * b + a * c
  /-- Multiplication is right distributive over addition -/
  right_distrib : ‚àÄ a b c : R, (a + b) * c = a * c + b * c

instance {R : Type} [Ring‚ÇÉ R] : AddCommGroup‚ÇÉ R :=
{ Ring‚ÇÉ.toAddGroup‚ÇÉ with
  add_comm := by
    intro a b
    have : a + (b + a) + b = a + (a + b) + b := by
      calc
        a + (b + a) + b = a + ((b + a) + b) := by rw [add_assoc‚ÇÉ]
        _ = a + (b + a + b) := by rw [add_assoc‚ÇÉ]
        _ = a + (b + (a + b)) := by rw [add_assoc‚ÇÉ]
        _ = (a + b) + (a + b) := by rw [add_assoc‚ÇÉ]
        _ = (a + b) * 1 + (a + b) * 1 := by rw [mul_one]
        _ = (a + b) * (1 + 1) := by rw [Ring‚ÇÉ.left_distrib]
        _ = a * (1 + 1) + b * (1 + 1) := by rw [Ring‚ÇÉ.right_distrib]
        _ = a * 1 + a * 1 + (b * 1 + b * 1) := by rw [Ring‚ÇÉ.left_distrib, Ring‚ÇÉ.left_distrib]
        _ = a + a + (b + b) := by simp
        _ = a + (a + (b + b)) := by rw [add_assoc‚ÇÉ]
        _ = a + ((a + b) + b) := by rw [add_assoc‚ÇÉ]
        _ = a + (a + b) + b := by rw [‚Üêadd_assoc‚ÇÉ]
    apply add_right_cancel‚ÇÉ at this
    apply add_left_cancel‚ÇÉ at this
    exact symm this
}

instance : Ring‚ÇÉ ‚Ñ§ where
  add := (¬∑ + ¬∑)
  add_assoc‚ÇÉ := add_assoc
  zero := 0
  zero_add := by simp
  add_zero := by simp
  neg := (- ¬∑)
  neg_add := by simp
  mul := (¬∑ * ¬∑)
  mul_assoc‚ÇÉ := mul_assoc
  one := 1
  one_mul := by simp
  mul_one := by simp
  zero_mul := by simp
  mul_zero := by simp
  left_distrib := Int.mul_add
  right_distrib := Int.add_mul

class LE‚ÇÅ (Œ± : Type) where
  /-- The Less-or-Equal relation. -/
  le : Œ± ‚Üí Œ± ‚Üí Prop

@[inherit_doc] infix:50 " ‚â§‚ÇÅ " => LE‚ÇÅ.le

/-
1. Reflexivity: ‚àÄ a : Œ±, a ‚â§‚ÇÅ a
1. Transitivity (a b c : Œ±) (ab : a ‚â§‚ÇÅ b) (bc : b ‚â§‚ÇÅ c) : a ‚â§‚ÇÅ c
-/
class Preorder‚ÇÅ (Œ± : Type) extends LE‚ÇÅ Œ± where
  le_refl : ‚àÄ a : Œ±, a ‚â§‚ÇÅ a
  le_trans : ‚àÄ a b c : Œ±, a ‚â§‚ÇÅ b ‚Üí b ‚â§‚ÇÅ c ‚Üí a ‚â§‚ÇÅ c

/-
1. Extends Preorder
1. Antisymmetry (a b : Œ±) (ab : a ‚â§‚ÇÅ b) (ba : b ‚â§‚ÇÅ a) : a = b
-/
class PartialOrder‚ÇÅ (Œ± : Type) extends Preorder‚ÇÅ Œ±, CommMonoid‚ÇÉ Œ± where
  le_antisymm : ‚àÄ a b : Œ±, a ‚â§‚ÇÅ b ‚Üí b ‚â§‚ÇÅ a ‚Üí a = b

/- a class for ordered commutative monoids, which have both a partial order and a commutative monoid structure such that
‚àÄ a b : Œ±, a ‚â§ b ‚Üí ‚àÄ c : Œ±, c * a ‚â§ c * b.
-/
class OrderedCommMonoid‚ÇÅ (Œ± : Type) extends PartialOrder‚ÇÅ Œ± where
  le_of_mul : ‚àÄ a b : Œ±, a ‚â§‚ÇÅ b ‚Üí ‚àÄ c : Œ±, c * a ‚â§‚ÇÅ c * b

instance : OrderedCommMonoid‚ÇÅ ‚Ñï where
  le := (¬∑ ‚â§ ¬∑)
  le_refl := by simp
  le_trans := by intro a b c ; exact Nat.le_trans
  one_mul := by simp
  mul_one := by simp
  mul_assoc‚ÇÉ := by intro a b c ; exact Nat.mul_assoc a b c
  mul_comm := by intro a b ; exact Nat.mul_comm a b
  le_antisymm := by intro a b ; simp ; exact Nat.le_antisymm
  le_of_mul := by
    intro a b ab
    intro c
    simp at ab
    simp
    exact Nat.mul_le_mul_left c ab

class SMul‚ÇÉ (Œ± : Type) (Œ≤ : Type) where
  /-- Scalar multiplication -/
  smul : Œ± ‚Üí Œ≤ ‚Üí Œ≤

infixr:73 " ‚Ä¢ " => SMul‚ÇÉ.smul


class Module‚ÇÅ (R : Type) [Ring‚ÇÉ R] (M : Type) [AddCommGroup‚ÇÉ M] extends SMul‚ÇÉ R M where
  zero_smul : ‚àÄ m : M, (0 : R) ‚Ä¢ m = 0
  one_smul : ‚àÄ m : M, (1 : R) ‚Ä¢ m = m
  mul_smul : ‚àÄ (a b : R) (m : M), (a * b) ‚Ä¢ m = a ‚Ä¢ b ‚Ä¢ m
  add_smul : ‚àÄ (a b : R) (m : M), (a + b) ‚Ä¢ m = a ‚Ä¢ m + b ‚Ä¢ m
  smul_add : ‚àÄ (a : R) (m n : M), a ‚Ä¢ (m + n) = a ‚Ä¢ m + a ‚Ä¢ n

instance selfModule (R : Type) [Ring‚ÇÉ R] : Module‚ÇÅ R R where
  smul := fun r s ‚Ü¶ r*s
  zero_smul := zero_mul
  one_smul := one_mul
  mul_smul := mul_assoc‚ÇÉ
  add_smul := Ring‚ÇÉ.right_distrib
  smul_add := Ring‚ÇÉ.left_distrib

def nsmul‚ÇÅ [Zero M] [Add M] : ‚Ñï ‚Üí M ‚Üí M
  | 0, _ => 0
  | n + 1, a => a + nsmul‚ÇÅ n a

def zsmul‚ÇÅ {M : Type*} [Zero M] [Add M] [Neg M] : ‚Ñ§ ‚Üí M ‚Üí M
  | Int.ofNat n, a => nsmul‚ÇÅ n a
  | Int.negSucc n, a => -nsmul‚ÇÅ n.succ a

/- You are not asked to replace those sorries with proofs
If you insist on doing it then you will probably want to state and prove several intermediate lemmas about nsmul1 and zsmul‚ÇÅ. -/

lemma neg_zero_eq_zero {A : Type} [AddCommGroup‚ÇÉ A] : -(0 : A) = (0 : A) := by
  have : 0 + 0 = (0 : A) := by exact AddMonoid‚ÇÉ.zero_add 0
  exact neg_eq_of_add this

lemma neg_dist‚ÇÅ (m n : A) [AddCommGroup‚ÇÉ A] : -(m + n) = -m + -n := by
  apply neg_eq_of_add
  rw [AddCommGroup‚ÇÉ.add_comm m n]
  rw [‚Üêadd_assoc‚ÇÉ]
  nth_rewrite 2 [add_assoc‚ÇÉ]
  simp

lemma neg_neg_eq_cancel (m : A) [AddCommGroup‚ÇÉ A] : - -m = m := by
  rw [neg_eq_of_add]
  exact AddGroup‚ÇÉ.neg_add m

lemma zsmul_zero_eq_zero {m : A} [AddCommGroup‚ÇÉ A] : zsmul‚ÇÅ 0 m = 0 := rfl
lemma nsmul_zero_eq_zero {m : A} [AddCommGroup‚ÇÉ A] : nsmul‚ÇÅ 0 m = 0 := rfl

lemma zsmul_one_eq_cancel {m : A} [AddCommGroup‚ÇÉ A] : zsmul‚ÇÅ 1 m = m := by
  simp [zsmul‚ÇÅ]
  simp [nsmul‚ÇÅ]
lemma nsmul_one_eq_cancel {m : A} [AddCommGroup‚ÇÉ A] : nsmul‚ÇÅ 1 m = m := by
  simp [nsmul‚ÇÅ]

lemma zsmul_eq_nsmul {m : A} [AddCommGroup‚ÇÉ A] (a : ‚Ñï) : zsmul‚ÇÅ ‚Üëa m = nsmul‚ÇÅ a m := by
  simp [zsmul‚ÇÅ]

lemma zsmul_eq_nsmul_of_nonneg {m : A} [AddCommGroup‚ÇÉ A] (a : ‚Ñ§) (b : ‚Ñï) (h : a = ‚Üëb) :
    zsmul‚ÇÅ a m = nsmul‚ÇÅ b m := by
  rcases a with aN | aZ
  { rw [h] ; rfl }
  {
    have X : ¬¨ 0 ‚â§ Int.negSucc aZ := by exact of_decide_eq_false rfl
    have Y : 0 ‚â§ (‚Üëb : ‚Ñ§) := by exact Int.ofNat_zero_le b
    rw [h] at X
    exact absurd Y X
  }

lemma nsmul_neg_eq_neg_nsmul {m : A} [AddCommGroup‚ÇÉ A] (a : ‚Ñï) :
    nsmul‚ÇÅ a m = -nsmul‚ÇÅ a (-m) := by
  induction' a with a0 a1
  { simp [nsmul‚ÇÅ] ; exact Eq.symm neg_zero_eq_zero }
  {
    simp [nsmul‚ÇÅ]
    simp only [neg_dist‚ÇÅ, a1]
    have : m = - -m := by
      refine Eq.symm (neg_eq_of_add ?h)
      exact AddGroup‚ÇÉ.neg_add m
    rw [‚Üêthis]
  }

lemma add_left_dist‚ÇÅ (a b : ‚Ñ§) (m : A) [AddCommGroup‚ÇÉ A] : zsmul‚ÇÅ (a + b) m = zsmul‚ÇÅ a m + zsmul‚ÇÅ b m := by
  have zinc {m : A} (n : ‚Ñ§) : m + zsmul‚ÇÅ n m = zsmul‚ÇÅ (n + 1) m := by
    induction' n with nnn nn
    {
      induction' nnn with n0 _
      { simp [zsmul‚ÇÅ] ; exact rfl }
      {
        have : Int.ofNat (n0 + 1) = Int.ofNat n0 + 1 := rfl
        rw [this]
        nth_rewrite 2 [zsmul‚ÇÅ.eq_def]
        have : Int.ofNat n0 + 1 + 1 = Int.ofNat (n0 + 1 + 1) := by rfl
        rw [this]
        have : ‚Üën0 + 1 = Int.ofNat (n0 + 1) := by rfl
        simp only [zsmul‚ÇÅ, this]
        rfl
      }
    }
    {
      induction' nn with n hn
      {
        simp [zsmul‚ÇÅ]
        nth_rewrite 2 [nsmul‚ÇÅ.eq_def]
        simp
        simp only [nsmul‚ÇÅ]
        rw [add_zero]
        simp
      }
      {
        have flip (n : ‚Ñï) : zsmul‚ÇÅ (Int.negSucc n) m = -nsmul‚ÇÅ (n + 1) m := rfl
        by_cases n0 : n = 0
        {
          simp only [n0]
          rw [flip 1]
          have : Int.negSucc (0 + 1) + 1 = Int.negSucc 0 := rfl
          simp only [this]
          rw [flip 0]
          have : -nsmul‚ÇÅ (1 + 1) m = -(m + nsmul‚ÇÅ 1 m) := by exact flip 1
          simp [this]
          have : nsmul‚ÇÅ 1 m = m := by simp [nsmul‚ÇÅ]
          simp only [this]
          apply @add_right_cancel‚ÇÉ _ _ (m + m)
          rw [add_assoc‚ÇÉ m, AddCommSemigroup‚ÇÉ.add_comm (-(m + m)), @AddGroup‚ÇÉ.add_neg A _ (m + m)]
          simp
          simp [‚Üêadd_assoc‚ÇÉ]
        }
        {
          rw [flip] at hn
          rw [flip (n + 1)]
          have : Int.negSucc (n + 1) = Int.negSucc n - 1 := rfl
          rw [this]
          have : Int.negSucc n = Int.negSucc n - 1 + 1 := by exact rfl
          rw [‚Üê this]
          simp [flip]
          have val (n : ‚Ñï) : nsmul‚ÇÅ (n + 1) m = m + nsmul‚ÇÅ n m := by exact rfl
          have : nsmul‚ÇÅ (n + 1 + 1) m = m + nsmul‚ÇÅ (n + 1) m := by exact val (n + 1)
          simp [this]
          apply @add_right_cancel‚ÇÉ _ _ (m + nsmul‚ÇÅ (n + 1) m)
          rw [add_assoc‚ÇÉ m, AddCommSemigroup‚ÇÉ.add_comm (-(m + nsmul‚ÇÅ (n + 1) m)), @AddGroup‚ÇÉ.add_neg A _ _]
          rw [add_zero]
          rw [‚ÜêAddCommSemigroup‚ÇÉ.add_comm, add_assoc‚ÇÉ, ‚ÜêAddCommSemigroup‚ÇÉ.add_comm]
          rw [@AddGroup‚ÇÉ.add_neg, zero_add]
        }
      }
    }
  have z_zero : zsmul‚ÇÅ 0 m = 0 := by exact rfl
  rcases b with bN | bZ
  {
    induction' bN with b0 bP
    { simp [z_zero] }
    {
      have : Int.ofNat (b0 + 1) = Int.ofNat b0 + 1 := by rfl
      simp only [this]
      rw [‚Üê add_assoc‚ÇÉ]
      rw [‚Üê zinc]
      rw [bP]
      rw [‚Üê zinc]
      rw [‚Üê add_assoc‚ÇÉ]
      rw [‚Üê add_assoc‚ÇÉ]
      rw [AddCommSemigroup‚ÇÉ.add_comm _ m]
    }
  }
  {
    induction' bZ with b0 bP
    {
      simp
      have : m + zsmul‚ÇÅ (a + -1) m = zsmul‚ÇÅ (a + -1 + 1) m := by exact zinc (a + -1)
      simp [linarith] at this
      rw [‚Üê this]
      have : zsmul‚ÇÅ (-1) m = -m := by exact Eq.symm (neg_eq_of_add (zinc (-1)))
      rw [this]
      rw [AddCommSemigroup‚ÇÉ.add_comm m]
      rw [add_assoc‚ÇÉ]
      simp
    }
    {
      let c : ‚Ñ§ := Int.negSucc b0
      have as_c : c = Int.negSucc b0 := by rfl
      have : Int.negSucc (b0 + 1) = Int.negSucc b0 - 1 := rfl
      rw [this]
      rw [‚Üêas_c]
      rw [‚Üêas_c] at bP
      have : m + zsmul‚ÇÅ (a + c - 1) m = zsmul‚ÇÅ (a + c - 1 + 1) m := by exact zinc (a + c - 1)
      have sub1 : a + c - 1 = a + (c - 1) := by exact Int.add_sub_assoc a c 1
      have sub2 : a + c - 1 + 1 = a + c := by exact Int.sub_add_cancel (a + c) 1
      nth_rewrite 1 [sub1] at this
      rw [sub2] at this
      nth_rewrite 1 [‚Üêzero_add (zsmul‚ÇÅ _ _)]
      rw [‚Üê@AddGroup‚ÇÉ.add_neg _ _ m, AddCommSemigroup‚ÇÉ.add_comm m, add_assoc‚ÇÉ, this]
      have : zsmul‚ÇÅ (-1) m = -m := by exact Eq.symm (neg_eq_of_add (zinc (-1)))
      rw [bP, ‚Üêadd_assoc‚ÇÉ, AddCommGroup‚ÇÉ.add_comm (-m), add_assoc‚ÇÉ]
      have last_one : -m + zsmul‚ÇÅ c m = zsmul‚ÇÅ (c - 1) m := by
        symm
        simp [zsmul‚ÇÅ]
        have : c - 1 = Int.negSucc b0 - 1 := by rw [as_c]
        simp [this]
        simp [nsmul‚ÇÅ]
        have dist (a b : A) : -(a + b) = -a + -b := by
          have : a + b + (-a + -b) = 0 := by
            calc
              a + b + (-a + -b) = a + (b + (-a + -b)) := by exact add_assoc‚ÇÉ a b (-a + -b)
              _ = a + (b + (-b + -a)) := by rw [AddCommGroup‚ÇÉ.add_comm (-a)]
              _ = a + (b + -b + -a) := by rw [add_assoc‚ÇÉ b]
              _ = a + -a := by simp
              _ = 0 := by simp
          exact neg_eq_of_add this
        rw [‚Üêdist]
      rw [last_one]
    }
  }

lemma add_left_dist‚Ñï‚ÇÅ (a b : ‚Ñï) (m : A) [AddCommGroup‚ÇÉ A] : nsmul‚ÇÅ (a + b) m = nsmul‚ÇÅ a m + nsmul‚ÇÅ b m := by
  let az : ‚Ñ§ := Int.ofNat a
  let bz : ‚Ñ§ := Int.ofNat b
  have : zsmul‚ÇÅ (az + bz) m = zsmul‚ÇÅ az m + zsmul‚ÇÅ bz m := by exact add_left_dist‚ÇÅ az bz m
  exact this

lemma add_right_dist‚ÇÅ (a : ‚Ñ§) (m n : A) [AddCommGroup‚ÇÉ A] :
    zsmul‚ÇÅ a (m + n) = zsmul‚ÇÅ a m + zsmul‚ÇÅ a n := by
  by_cases aN : 0 ‚â§ a
  {
    induction' a with a0 ia
    {
      induction' a0 with a00 ia0
      { simp [zsmul‚ÇÅ, nsmul‚ÇÅ] }
      {
        simp only [zsmul‚ÇÅ]
        have : 0 ‚â§ Int.ofNat a00 := by exact Int.zero_le_ofNat a00
        simp [this] at ia0
        simp [zsmul‚ÇÅ] at ia0
        simp [add_left_dist‚Ñï‚ÇÅ]
        rw [ia0]
        simp [nsmul_one_eq_cancel]
        rw [‚Üêadd_assoc‚ÇÉ]
        nth_rewrite 1 [‚Üêadd_assoc‚ÇÉ]
        nth_rewrite 5 [AddCommGroup‚ÇÉ.add_comm]
        rw [‚Üêadd_assoc‚ÇÉ]
        nth_rewrite 6 [AddCommGroup‚ÇÉ.add_comm]
        rfl
      }
    }
    {
      have aNN : ¬¨0 ‚â§ Int.negSucc ia := by exact of_decide_eq_false rfl
      exact absurd aN aNN
    }
  }
  {
    simp only [zsmul‚ÇÅ]
    rcases a with an | ap
    {
      have aNN : 0 ‚â§ Int.ofNat an := by exact Int.zero_le_ofNat an
      exact absurd aNN aN
    }
    {
      simp
      induction' ap with a0 ia
      { simp [nsmul‚ÇÅ] ; exact neg_dist‚ÇÅ m n }
      {
        simp at ia
        -- left hand
        rw [add_left_dist‚Ñï‚ÇÅ]
        simp only [neg_dist‚ÇÅ, ia]
        rw [nsmul_one_eq_cancel]
        rw [neg_dist‚ÇÅ, ‚Üêadd_assoc‚ÇÉ]
        -- right hand
        nth_rewrite 3 [add_left_dist‚Ñï‚ÇÅ]
        rw [neg_dist‚ÇÅ]
        nth_rewrite 4 [add_left_dist‚Ñï‚ÇÅ]
        rw [neg_dist‚ÇÅ]
        simp only [nsmul_one_eq_cancel]
        nth_rewrite 3 [add_assoc‚ÇÉ]
        nth_rewrite 5 [AddCommGroup‚ÇÉ.add_comm]
        nth_rewrite 3 [add_assoc‚ÇÉ]
        nth_rewrite 6 [AddCommGroup‚ÇÉ.add_comm]
        nth_rewrite 2 [‚Üêadd_assoc‚ÇÉ]
        nth_rewrite 1 [‚Üêadd_assoc‚ÇÉ]
        nth_rewrite 1 [‚Üêadd_assoc‚ÇÉ]
        rfl
      }
    }
  }

lemma add_right_dist‚Ñï‚ÇÅ (a : ‚Ñï) (m n : A) [AddCommGroup‚ÇÉ A] :
    nsmul‚ÇÅ a (m + n) = nsmul‚ÇÅ a m + nsmul‚ÇÅ a n := by
  exact add_right_dist‚ÇÅ ‚Üëa m n

lemma mul_dist‚ÇÅ (a b : ‚Ñ§) (m : A) [AddCommGroup‚ÇÉ A] : zsmul‚ÇÅ (a * b) m = zsmul‚ÇÅ a (zsmul‚ÇÅ b m) := by
  have one_mul_eq_cancel (a : ‚Ñ§) (m : A) : zsmul‚ÇÅ a m = zsmul‚ÇÅ (Int.ofNat 1) (zsmul‚ÇÅ a m) := by
    nth_rewrite 2 [zsmul‚ÇÅ.eq_def]
    simp
    simp [nsmul‚ÇÅ]
  by_cases aN : 0 ‚â§ a
  {
    by_cases  bN : 0 ‚â§ b
    {
      have ap : 0 ‚â§ a * b := by exact Int.mul_nonneg aN bN
      rcases a with an | az
      {
        rcases b with bn | bz
        {
          induction' an with a0 ia
          { simp [zsmul‚ÇÅ, nsmul‚ÇÅ] }
          {
            have xx : 0 ‚â§ Int.ofNat a0 := by exact Int.zero_le_ofNat a0
            have xy : 0 ‚â§ Int.ofNat a0 * Int.ofNat bn := by exact Int.mul_nonneg xx bN
            rcases ia xx xy with ia'
            have : ‚àÄ x y z : ‚Ñ§, (x + y) * z = x * z + y * z := by exact add_mul
            /- „ÇÇ„Åó„Åã„Åó„Å¶zinc„Çí‰Ωø„Åà„Å∞„ÅÑ„ÅÑ„Å†„Åë„Åò„ÇÉ„Å™„Åã„Çç„Åã -/
            calc
              zsmul‚ÇÅ (Int.ofNat (a0 + 1) * Int.ofNat bn) m =
                zsmul‚ÇÅ ((Int.ofNat a0 + Int.ofNat 1) * Int.ofNat bn) m := by exact rfl
              _ = zsmul‚ÇÅ (Int.ofNat a0 * Int.ofNat bn + Int.ofNat 1 * Int.ofNat bn) m := by rw [add_mul]
              _ = zsmul‚ÇÅ (Int.ofNat a0 * Int.ofNat bn) m + zsmul‚ÇÅ (Int.ofNat 1 * Int.ofNat bn) m := by rw [add_left_dist‚ÇÅ (Int.ofNat a0 * Int.ofNat bn) (Int.ofNat 1 * Int.ofNat bn) m]
              _ = zsmul‚ÇÅ (Int.ofNat a0) (zsmul‚ÇÅ (Int.ofNat bn) m) + zsmul‚ÇÅ (Int.ofNat 1 * Int.ofNat bn) m := by rw [ia']
              _ = zsmul‚ÇÅ (Int.ofNat a0) (zsmul‚ÇÅ (Int.ofNat bn) m) + zsmul‚ÇÅ (Int.ofNat bn) m := by simp
              _ = zsmul‚ÇÅ (Int.ofNat a0) (zsmul‚ÇÅ (Int.ofNat bn) m) + zsmul‚ÇÅ (Int.ofNat 1) (zsmul‚ÇÅ (Int.ofNat bn) m) := by
                nth_rewrite 2 [one_mul_eq_cancel (Int.ofNat bn) m]
                rfl
              _ = zsmul‚ÇÅ (Int.ofNat a0 + Int.ofNat 1) (zsmul‚ÇÅ (Int.ofNat bn) m) := by rw [
                ‚Üêadd_left_dist‚ÇÅ (Int.ofNat a0) (Int.ofNat 1) (zsmul‚ÇÅ (Int.ofNat bn) m)]
              _ = zsmul‚ÇÅ (Int.ofNat (a0 + 1)) (zsmul‚ÇÅ (Int.ofNat bn) m) := by exact rfl
          }
        }
        {
          induction' an with a0 ia
          { simp [zsmul‚ÇÅ,nsmul‚ÇÅ] }
          {
            have : Int.ofNat (a0 + 1) = Int.ofNat a0 + Int.ofNat 1 := rfl
            rw [this]
            rw [add_mul]
            rw [add_left_dist‚ÇÅ]
            have : zsmul‚ÇÅ (Int.ofNat a0 * Int.negSucc bz) m = zsmul‚ÇÅ (Int.ofNat a0) (zsmul‚ÇÅ (Int.negSucc bz) m) := by
              have an' : 0 ‚â§ Int.ofNat a0 := by exact Int.zero_le_ofNat a0
              have ap' : 0 ‚â§ Int.ofNat a0 * Int.negSucc bz := by exact Int.mul_nonneg an' bN
              exact ia an' ap'
            rw [this]
            rw [add_left_dist‚ÇÅ]
            simp
            have : 1 = Int.ofNat 1 := rfl
            rw [this, ‚Üêone_mul_eq_cancel (Int.negSucc bz)]
          }
        }
      }
      {
        have aNN : ¬¨ 0‚â§ Int.negSucc az := by exact of_decide_eq_false rfl
        exact absurd aN aNN
      }
    }
    {
      rcases a with a_N | a_Z
      {
        induction' a_N with a0 ia
        { simp [zsmul‚ÇÅ,nsmul‚ÇÅ] }
        {
          have : Int.ofNat (a0 + 1) = Int.ofNat a0 + Int.ofNat 1 := rfl
          simp only [this]
          have : (Int.ofNat a0 + Int.ofNat 1) * b = (Int.ofNat a0) * b + b := by exact add_one_mul (‚Üëa0) b
          simp only [this]
          rw [add_left_dist‚ÇÅ]
          have : 0 ‚â§ Int.ofNat a0 := by exact Int.zero_le_ofNat a0
          rw [ia this]
          nth_rewrite 3 [one_mul_eq_cancel]
          rw [add_left_dist‚ÇÅ]
        }
      }
      {
        have aNN : ¬¨0‚â§ Int.negSucc a_Z := by exact of_decide_eq_false rfl
        exact absurd aN aNN
      }
    }
  }
  {
    -- case: a < 0
    induction' b with bN0 bNp
    {
      {
        induction' bN0 with bNN0 bNNN
        {
          simp
          simp [zsmul_zero_eq_zero]
          have nsmul_zero : ‚àÄ n : ‚Ñï, nsmul‚ÇÅ n (0 : A) = 0 := by
            intro n
            induction' n with n0 hn
            { simp [nsmul‚ÇÅ] }
            { simp [nsmul‚ÇÅ] ; exact hn }
          have zsmul_zero (a : ‚Ñ§) : zsmul‚ÇÅ a (0 : A) = 0 := by
            rcases a with aN | aZ
            { exact nsmul_zero aN }
            {
              induction' aZ with aZ0 aZZ
              {
                simp [zsmul‚ÇÅ, nsmul‚ÇÅ]
                exact neg_zero_eq_zero
              }
              {
                have dec (a : ‚Ñï) : Int.negSucc (a + 1) = Int.negSucc a + -1 := rfl
                simp only [dec]
                simp [add_left_dist‚ÇÅ, aZZ]
                simp [zsmul‚ÇÅ]
                have : (-1 : ‚Ñ§) = Int.negSucc 0 := rfl
                simp only [this, nsmul_zero]
                exact neg_zero_eq_zero
              }
            }
          simp only [zsmul_zero]
        }
        have ds : a * Int.ofNat (bNN0 + 1) = a * Int.ofNat bNN0 + a := by
          calc
            a * Int.ofNat (bNN0 + 1) = a * (Int.ofNat bNN0 + Int.ofNat 1) := rfl
            _ = a * Int.ofNat bNN0 + a * Int.ofNat 1 := by
              rw [Ring‚ÇÉ.left_distrib a (Int.ofNat bNN0) (Int.ofNat 1)]
            _ = a * Int.ofNat bNN0 + a * 1 := rfl
            _ = a * Int.ofNat bNN0 + a := by rw [Monoid‚ÇÉ.mul_one a]
        rw [ds]
        have : Int.ofNat (bNN0 + 1) = Int.ofNat bNN0 + Int.ofNat 1 := rfl
        rw [this]
        rw [add_left_dist‚ÇÅ]
        rw [add_left_dist‚ÇÅ]
        rw [bNNN]
        simp only [add_right_dist‚ÇÅ]
        have : zsmul‚ÇÅ (Int.ofNat 1)  m = m := by simp [zsmul‚ÇÅ, nsmul‚ÇÅ]
        rw[this]
      }
    }
    {
      induction' bNp with bN0 ib
      {
        simp
        simp [zsmul‚ÇÅ]
        induction' a with aN0 aNN
        {
          induction' aN0 with aN0' ia
          { simp [nsmul‚ÇÅ] }
          {
            simp at ia
            have : 0 ‚â§ Int.ofNat (aN0' + 1) := by exact Int.zero_le_ofNat (aN0' + 1)
            exact absurd this aN
          }
        }
        {
          simp at aN
          simp
          have : -Int.negSucc aNN = Int.ofNat (aNN + 1) := rfl
          simp only [this]
          have : -1 = Int.negSucc 0 := rfl
          simp only [this]
          simp [nsmul_one_eq_cancel]
          rw [nsmul_neg_eq_neg_nsmul]
        }
      }
      {
        have : a * (Int.negSucc (bN0 + 1)) = a * Int.negSucc bN0 + -a := by
          calc
            a * (Int.negSucc (bN0 + 1)) = a * (Int.negSucc bN0 + -1) := rfl
            _ = a * Int.negSucc bN0 - a := by exact mul_sub_one a (Int.negSucc bN0)
        simp only [this]
        rw [add_left_dist‚ÇÅ (a * Int.negSucc bN0)]
        simp only [ib]
        -- right hand
        have : Int.negSucc (bN0 + 1) = Int.negSucc bN0 + -1 := rfl
        simp only [this]
        simp only [add_left_dist‚ÇÅ]
        rw [add_right_dist‚ÇÅ]
        have : (zsmul‚ÇÅ (-1) m) = -m := by
          simp [zsmul‚ÇÅ]
          have : -1 = Int.negSucc 0 := rfl
          rw [this]
          simp [nsmul‚ÇÅ]
        simp only [this]
        have : zsmul‚ÇÅ a (-m) = zsmul‚ÇÅ (-a) m := by
          simp [zsmul‚ÇÅ]
          induction' a with a_N a_Z
          {
            have aNN : 0 ‚â§ Int.ofNat a_N := by exact Int.zero_le_ofNat a_N
            exact absurd aNN aN
          }
          {
            induction' a_Z with a_Z0 ia
            {
              simp [nsmul‚ÇÅ]
              rw [neg_eq_of_add]
              exact AddGroup‚ÇÉ.neg_add m
            }
            {
              simp at ia
              simp at ib
              have : -Int.negSucc (a_Z0 + 1) = Int.ofNat (a_Z0 + 2) := rfl
              simp [nsmul‚ÇÅ]
              simp only [this]
              rw [neg_dist‚ÇÅ, neg_dist‚ÇÅ]
              simp only [neg_neg_eq_cancel]
              rw [‚Üêadd_assoc‚ÇÉ]
              have : a_Z0 + 2 = (a_Z0 + 1) + 1 := rfl
              simp only [this]
              rw [add_left_dist‚Ñï‚ÇÅ (a_Z0 + 1) 1 m]
              rw [nsmul_one_eq_cancel]
              rw [add_left_dist‚Ñï‚ÇÅ a_Z0 1 m]
              rw [nsmul_one_eq_cancel]
              rw [nsmul_neg_eq_neg_nsmul]
              simp only [neg_neg_eq_cancel]
              rw [AddCommGroup‚ÇÉ.add_comm, add_assoc‚ÇÉ]
           }
          }
        simp only [this]
      }
    }
  }

instance abGrpModule (A : Type) [AddCommGroup‚ÇÉ A] : Module‚ÇÅ ‚Ñ§ A where
  smul := zsmul‚ÇÅ
  zero_smul := by intro _ ; simp [zsmul‚ÇÅ, nsmul‚ÇÅ]
  one_smul := by intro x ; simp [zsmul‚ÇÅ, nsmul‚ÇÅ]
  mul_smul := by intro x y m ; simp ; exact mul_dist‚ÇÅ x y m
  add_smul := by intro a b c ; simp ; exact add_left_dist‚ÇÅ a b c
  smul_add := by intro a b c ; simp ; exact add_right_dist‚ÇÅ a b c

#synth Module‚ÇÅ ‚Ñ§ ‚Ñ§ -- abGrpModule ‚Ñ§


class AddMonoid‚ÇÑ (M : Type) extends AddSemigroup‚ÇÉ M, AddZeroClass M where
  /-- Multiplication by a natural number. -/
  nsmul : ‚Ñï ‚Üí M ‚Üí M := nsmul‚ÇÅ
  /-- Multiplication by `(0 : ‚Ñï)` gives `0`. -/
  nsmul_zero : ‚àÄ x, nsmul 0 x = 0 := by intros; rfl
  /-- Multiplication by `(n + 1 : ‚Ñï)` behaves as expected. -/
  nsmul_succ : ‚àÄ (n : ‚Ñï) (x), nsmul (n + 1) x = x + nsmul n x := by intros; rfl

instance mySMul {M : Type} [AddMonoid‚ÇÑ M] : SMul ‚Ñï M := ‚ü®AddMonoid‚ÇÑ.nsmul‚ü©

instance (M N : Type) [AddMonoid‚ÇÑ M] [AddMonoid‚ÇÑ N] : AddMonoid‚ÇÑ (M √ó N) where
  add := fun p q ‚Ü¶ (p.1 + q.1, p.2 + q.2)
  add_assoc‚ÇÉ := fun a b c ‚Ü¶ by ext <;> apply add_assoc‚ÇÉ
  zero := (0, 0)
  zero_add := fun a ‚Ü¶ by ext <;> apply zero_add
  add_zero := fun a ‚Ü¶ by ext <;> apply add_zero

instance : AddMonoid‚ÇÑ ‚Ñ§ where
  add := (¬∑ + ¬∑)
  add_assoc‚ÇÉ := Int.add_assoc
  zero := 0
  zero_add := Int.zero_add
  add_zero := Int.add_zero
  nsmul := fun n m ‚Ü¶ (n : ‚Ñ§) * m
  nsmul_zero := Int.zero_mul
  nsmul_succ := fun n m ‚Ü¶ show (n + 1 : ‚Ñ§) * m = m + n * m
    by rw [Int.add_mul, Int.add_comm, Int.one_mul]

example (n : ‚Ñï) (m : ‚Ñ§) : SMul.smul (self := mySMul) n m = n * m := rfl
